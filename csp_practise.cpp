

////////////////////////////////////////////////////////////////////////////////////
//
//
//		date:2018.7.23
//			
//		CCF csp模拟试题库
//			
//		question:	 	count:66
//
//		Finish:	
//
//		*:write but not AC	!:do not understand		-:not finish LOOK the book
//			
//
////////////////////////////////////////////////////////////////////////////////////

// http://118.190.20.162/home.page


// 201803-4 棋局评估  查看我的提交 查看试题/答题 

// #include <cstdio>
// using namespace std;
// int map[4][4];

// int main()
// {
// 	int T;
// 	scanf("%d",&T);
// 	while(T--){
// 		for(int i=0;i<3;i++)
// 			for(int j=0;j<;j++)
// 				scanf("%d",&map[i][j]);

// 	}
// 	return 0;
// }

// 9!用dfs遍历查找


// 201803-5 二次求和  查看我的提交 查看试题/答题 

// 虑单次询问的答案为多少(S为前缀和，SS为S
// 的前缀和)：
// ans=∑k=lr∑i=kn(Si−Si−k)
// =∑k=lr(∑i=knSi−∑i=0n−kSi)
// =∑k=lr(SSn−SSk−1−SSn−k)
// =(r−l+1)SSn−∑i=l−1r−1SSi−∑i=n−rn−lSSi
// 所以我们应该用线段树维护SS
// ，那么考虑一次修改的影响。
// 对于 l≤i≤r，SSi+=(i−l+1)(i−l+2)2v
// 对于 i>r，SSi+=len(len+1)2v+len(i−r)v，len=r−l+1
// 即影响是一个关于 i 的二次函数 ，可以化简为 ai2+bi+c 的形式，所以我们线段树维护区间SS的和及标记 a,b,c即可。
// 公式转化，推导前缀和


// 201712-2 游戏  查看我的提交 查看试题/答题 
// 约瑟夫环
// 使用队列操作 queue<int> d; 建立队列并每次标记


// 201712-4 行车路线  查看我的提交 查看试题/答题 
// Dijkstra
// 问题的难点在于连续走小路L1，L2时，产生的疲劳值是 (L1 + L2)2 而不是 L12 + L22.
// 解决思路是把大路和小路分开在两张图考虑。由于小路的疲劳值是连续计算再平方的，所以首先用一个Floyd算法计算小路图的点对点最短路。
// 如果直接用最普通的4行Floyd法O(n3)会超时，可以利用小路图矩阵的对称性优化一下常数，就不会超时了。


// 201712-5 商路  查看我的提交 查看试题/答题 									//?????????

// 201709-4 通信网络  查看我的提交 查看试题/答题 
// 下面是DFS思路, 准确来说是双向DFS
//         在有向图中, 对于一个点, 它的DFS遍历可达的点是它可传递信息的点.
//         它的反向DFS遍历(边的方向反转)可达的点是可传递信息到它的点.
//         那么我们获取这两种点, 如果这两种点集包含除自己以外的所有点, 那么答案+1.


// 201709-5 除法  查看我的提交 查看试题/答题 
// BIT


// 201703-2 学生排队  查看我的提交 查看试题/答题 	
// 暴力


// 201703-4 地铁修建  查看我的提交 查看试题/答题 								
// 求“修建整条地铁线路最少需要的天数”，即求解从起点到终点这条路径下各个连通节点之间的最长边
// 【分析】
// 　　可套用Dijkstra算法，只不过将松弛操作改为最长边。本题中我们用Dijkstra算法不是要得到最短路径，
// 而是要得到从起点到终点这条路径下各个连通节点之间的最长边。  


// 201703-5 引水入城  查看我的提交 查看试题/答题 								//??????????

// dp? 有点像暴力



// 201612-4 压缩编码  查看我的提交 查看试题/答题 								//..........
// 至少可以看出编码后字符的长度等于(每个字符出现的频数 x 字符在二叉树中的层数)之和，
// 而层数换种说法就是该字符被合并的次数。如果之前了解”石子合并”的问题，想到这就应该明白这个压缩编码的
// 问题其实就等同于石子合并，石子合并的结果就是(每个石头堆的石子数 x 被合并的次数)之和。
// 　　字 符 ----> 石子堆
// 　　频 数 ----> 石头数量
// 　　子树合并 ----> 石子堆合并
// 　　编码长度 ----> 游戏得分

// 设dp[i][j]表示第i到第j堆石子合并的最优值，sum[i][j]表示第i到第j堆石子的总数量。那么就有状态转移公式：

// 1、dp[i][j]=0 (i==j)

// 2、dp[i][j]=min(dp[i][k]+dp[k][j])+sum[i][j] (i!=j)

// 此时算法复杂为O(n^3).

// int solve(int l, int r)
// {
//     if(dp[l][r] == INT_MAX2)
//         for(int i = l; i < r; i++)
//             dp[l][r] = min(dp[l][r], solve(l, i) + solve(i+1, r) + sum[r] - sum[l-1]);
 
//     return dp[l][r];
// }
// int  run(int a[],int n){
//     for(int i=0;i<n;i++){
//         dp[i][i]=0;
//     }
//     for(int v=1;v<n;v++){
//         for(int i=0;i<n-v;i++){
//             int j=i+v;
//             dp[i][j]=INF;
//             int s=sum[j]-sum[i]+a[i];
//             for(int k=i;k<j;k++){
//                 dp[i][j]=min(dp[i][k]+dp[k+1][j]+s,dp[i][j]);
//             }
//         }
//     }
//     return dp[0][n-1];
// }

// 201612-5 卡牌游戏  查看我的提交 查看试题/答题 
// 思路：马尔可夫过程，转为求解方程组：每一种状态有一个概率，把概率转移方程列出来，用高斯消元法求解。

// 由于一共有2^n-2个方程，n最大为15，高斯消元法解方程是三次方的，无法通过极限数据。方程组是稀疏的，不知道要怎么优化。



// 201609-4 交通规划  查看我的提交 查看试题/答题 

// 使得任何两个城市间都可以通过高速铁路到达
// 而且从所有城市乘坐高速铁路到首都的最短路程和原来一样长。
// 所有道路最短路，将还是铁路的部分删除后观察是否联通



// 201609-5 祭坛  查看我的提交 查看试题/答题 									//??????????
// 先离散化，把空间限定在300000*300000的范围内。

// 做法一：预处理每个点上下左右的节点个数，分分钟写完，时间复杂度O(n^2)，可以拿到【60分】。

// 做法二：两次线段树。枚举y坐标值，维护当前y坐标上方和下方的节点个数。第一次线段树求出最优结界层数best。如果是询问一，
// 那输出答案。如果是询问二，
// 以best为阙值再构造一个线段树，统计结界层数==best的方案树。代码略长。时间复杂度O(nlogn) 【100分】


// 201604-4 游戏  查看我的提交 查看试题/答题 

// DFS
// 方格图上有一些方格是始终安全的，有一些在一段时间是危险的
// 每个单位时间，小明的角色必须向上下左右四个方向相邻的方格中的一个移动一格。

// 201604-5 网络连接  查看我的提交 查看试题/答题 

// 道路数量有限，道路具有费用 djistra / 图论


// 201512-4 送货  查看我的提交 查看试题/答题 									//?????????

// 再从新的路口出发去往下一个路口，直到所有的街道都经过了正好一次。
// 1.用图的数据初始化顶点，vis标记设为false。
// 2.按上述方法寻找起点，同时排除不合法情况。
// 3.从起点开始DFS，每次访问到顶点x的时候，将vis标记设为true，枚举x的邻接边，如果边没有被删除（del标记为false），那么就删除这条边（del设为true），同时找到下一个顶点，也删除这条边
// （无向图），DFS下一顶点，直到无法扩展，将顶点压栈。最后得到的栈按顺序出栈得到的序列就是顶点的访问顺序。
// 4.检查顶点的访问情况，如果有没有访问到的顶点就说明图不是连通图，不是合法情况。


// 201512-5 矩阵  查看我的提交 查看试题/答题 									//????.....

// 数学模型


// 201509-4 高速公路  查看我的提交 查看试题/答题 								//..........

// 暴力计数，筛选   
// 强连通图问题.......


// 201509-5 最佳文章  查看我的提交 查看试题/答题 

// 单词前后缀重合并计数


// 201503-4 网络延时  查看我的提交 查看试题/答题 
// 201503-5 最小花费  查看我的提交 查看试题/答题 


// 201412-4 最优灌溉  查看我的提交 查看试题/答题 
// 201412-5 货物调度  查看我的提交 查看试题/答题 


// 201409-4 最优配餐  查看我的提交 查看试题/答题 
// 201409-5 拼图  查看我的提交 查看试题/答题 


// 201403-4 无线网络  查看我的提交 查看试题/答题 
// 201403-5 任务调度  查看我的提交 查看试题/答题 


// 201312-4 有趣的数  查看我的提交 查看试题/答题 
// 201312-5 I’m stuck!  查看我的提交 查看试题/答题 
